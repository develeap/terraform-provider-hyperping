# Terraform Provider testing workflow.
name: Tests

# This GitHub action runs your tests for each pull request and push.
# Optionally, you can turn it on using a schedule for regular testing.
on:
  pull_request:
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - 'examples/**'
      - '*.md'
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - 'examples/**'
      - '*.md'

# Testing only needs permissions to read the repository contents.
permissions:
  contents: read

jobs:
  # Ensure project builds before running testing matrix
  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
      - run: go mod download
      - run: go build -v .
      - name: Run linters
        uses: golangci/golangci-lint-action@v9
        with:
          version: latest

  # Auto-generate and commit documentation
  generate:
    name: Documentation
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.head_ref }}
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
      # We need the latest version of Terraform for our documentation generation to use
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
      - name: Generate documentation
        run: |
          # Backup manual documentation before generation
          if [ -d "docs/guides" ]; then
            cp -r docs/guides /tmp/docs-guides-backup
          fi
          if [ -f "docs/index.md" ]; then
            cp docs/index.md /tmp/docs-index-backup.md
          fi
          if [ -f "docs/TROUBLESHOOTING.md" ]; then
            cp docs/TROUBLESHOOTING.md /tmp/docs-troubleshooting-backup.md
          fi

          # Generate schema-based documentation
          cd tools && go run github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs generate --provider-dir .. --provider-name hyperping
          cd ..

          # Restore manual documentation
          if [ -d "/tmp/docs-guides-backup" ]; then
            cp -r /tmp/docs-guides-backup docs/guides
          fi
          if [ -f "/tmp/docs-index-backup.md" ]; then
            cp /tmp/docs-index-backup.md docs/index.md
          fi
          if [ -f "/tmp/docs-troubleshooting-backup.md" ]; then
            cp /tmp/docs-troubleshooting-backup.md docs/TROUBLESHOOTING.md
          fi
      - name: Check for changes and auto-commit
        run: |
          # Only check and commit generated docs (resources, data-sources)
          if ! git diff --exit-code --quiet docs/resources/ docs/data-sources/; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add docs/resources/ docs/data-sources/
            git commit -m "docs: auto-generate updated documentation [skip ci]"
            git push
            echo "✅ Documentation updated and committed"
          else
            echo "✅ Documentation already up to date"
          fi

  # Security scanning with SARIF upload to GitHub Security tab
  security:
    name: Security
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest
      - name: Run govulncheck
        run: govulncheck ./...
      - name: Run gosec
        uses: securego/gosec@master
        with:
          args: -exclude-generated -exclude-dir=tools -fmt sarif -out gosec-results.sarif ./...
      - name: Upload gosec results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: gosec-results.sarif

  # Run unit tests (no API key required)
  unit-test:
    name: Unit Tests
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
      - run: go mod download
      - name: Run unit tests with coverage
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./internal/...
      - name: Check coverage threshold
        run: |
          # Coverage Analysis:
          # - Client package: 99%+ (pure unit tests - full coverage)
          # - Provider non-CRUD code: 100% (factory, Configure, Metadata, Schema, mapping)
          # - Provider CRUD: 0% unit tests (tested via acceptance tests - TF framework limitation)
          # - Total: 52%+ (reflects unit testable code)
          #
          # Note: CRUD operations (Create/Read/Update/Delete/ImportState) require TF Plugin
          # Framework fixtures to unit test. These are thoroughly tested via acceptance tests.

          echo "=== Coverage Analysis ==="
          go tool cover -func=coverage.out | grep -E "total:"

          TOTAL_COVERAGE=$(go tool cover -func=coverage.out | grep "^total:" | awk '{print $3}' | tr -d '%')

          echo ""
          echo "Unit test coverage: ${TOTAL_COVERAGE}%"
          echo ""
          echo "Coverage breakdown:"
          echo "  - Client package: ~99% (full unit test coverage)"
          echo "  - Provider helpers/mapping: 100%"
          echo "  - Provider CRUD: tested via acceptance tests (TestAcc*)"
          echo ""

          # Threshold: 42% (unit-testable code without TF framework fixtures)
          if [ $(echo "$TOTAL_COVERAGE < 42" | bc -l) -eq 1 ]; then
            echo "❌ Coverage ${TOTAL_COVERAGE}% is below 42% threshold"
            exit 1
          fi
          echo "✅ Unit test coverage ${TOTAL_COVERAGE}% meets 42% threshold"
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.out,./coverage_provider.out
          flags: unittests
          fail_ci_if_error: false
        continue-on-error: true

  # API Sync Check - ensures provider matches documented API
  # This blocks PRs if the provider is out of sync with API documentation
  sync-check:
    name: API Sync Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Restore scraper snapshots
        uses: actions/cache@v4
        with:
          path: |
            tools/cmd/scraper/.scraper_cache.json
            tools/cmd/scraper/snapshots/
            tools/cmd/scraper/docs_scraped/
          key: scraper-data-
          restore-keys: |
            scraper-data-

      - name: Build scraper
        working-directory: tools/cmd/scraper
        run: go build -o scraper

      - name: Check for snapshots
        id: check-snapshots
        working-directory: tools/cmd/scraper
        run: |
          if [ -d "./snapshots" ] && [ "$(ls -A ./snapshots 2>/dev/null)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "Snapshots found, proceeding with sync check"
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "No snapshots found - this is expected on first run or after cache expiry"
            echo "Sync check will be skipped. Run the scraper workflow first to populate snapshots."
          fi

      - name: Run sync check
        if: steps.check-snapshots.outputs.found == 'true'
        working-directory: tools/cmd/scraper
        run: |
          ./scraper -sync \
            -provider-dir=../../../internal \
            -snapshot-dir=./snapshots

      - name: Sync check skipped notice
        if: steps.check-snapshots.outputs.found != 'true'
        run: |
          echo "::warning::Sync check skipped - no API snapshots available. Run 'API Documentation Scraper' workflow first."

  # Run acceptance tests in a matrix with Terraform CLI versions
  # Only runs when API key is available (not on PRs from forks)
  acceptance-test:
    name: 'Acceptance Tests: Terraform ${{ matrix.terraform }}'
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Only run acceptance tests when we have access to secrets
    if: github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository
    strategy:
      fail-fast: false
      matrix:
        # Terraform versions
        # Supporting TF 1.7.x (current stable) and 1.8.x (latest)
        terraform:
          - '1.7.*'
          - '1.8.*'
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ matrix.terraform }}
          terraform_wrapper: false
      - run: go mod download
      - name: Run acceptance tests
        env:
          TF_ACC: "1"
          HYPERPING_API_KEY: ${{ secrets.HYPERPING_API_KEY }}
        run: go test -v -cover -timeout 120m ./internal/provider/
        if: env.HYPERPING_API_KEY != ''
      - name: Skip acceptance tests (no API key)
        if: env.HYPERPING_API_KEY == ''
        run: echo "Skipping acceptance tests - HYPERPING_API_KEY not available"
        env:
          HYPERPING_API_KEY: ${{ secrets.HYPERPING_API_KEY }}
